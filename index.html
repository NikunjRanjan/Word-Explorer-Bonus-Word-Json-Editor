<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Bonus Word Editor</title>

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #151515;
        color: #e6e6e6;
        font-family:
          Segoe UI,
          Arial,
          sans-serif;
        overflow: hidden;
      }

      .root {
        display: flex;
        height: 100%;
      }
      .panel {
        padding: 10px;
        display: flex;
        flex-direction: column;
      }
      .left {
        width: 30%;
        background: #252526;
      }
      .center {
        width: 40%;
        background: #1e1e1e;
      }
      .right {
        width: 30%;
        background: #252526;
      }
      .resizer {
        width: 6px;
        background: #333;
        cursor: col-resize;
      }

      h2 {
        font-size: 13px;
        margin: 8px 0 4px;
        border-bottom: 1px solid #333;
        color: #9cdcfe;
      }

      textarea,
      input,
      select {
        background: #1e1e1e;
        color: #dcdcdc;
        border: 1px solid #333;
        padding: 6px;
        margin-bottom: 6px;
        font-size: 12px;
      }

      textarea {
        flex: 1;
        resize: none;
        font-family: Consolas, monospace;
      }

      button {
        padding: 6px;
        background: #6a5acd;
        border: none;
        color: white;
        cursor: pointer;
        margin-bottom: 6px;
      }

      .list {
        flex: 1;
        overflow-y: auto;
        border: 1px solid #333;
        padding: 6px;
      }

      .word {
        display: inline-block;
        padding: 4px 8px;
        margin: 3px;
        border-radius: 3px;
        font-size: 12px;
        cursor: pointer;
      }

      .bonus {
        background: #264f78;
      }
      .bonus.invalid {
        background: #5a1f1f;
      }
      .removed {
        background: #7a6a1f;
      }
      .possible {
        background: #3a3a3a;
      }
      .possible.blocked {
        background: #a33a3a;
        cursor: not-allowed;
      }

      .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #a33a3a;
        color: #fff;
        padding: 10px 16px;
        border-radius: 4px;
        opacity: 0;
        transition: opacity 0.25s;
      }
      .toast.show {
        opacity: 1;
      }

      label {
        font-size: 12px;
        margin-bottom: 6px;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="panel left">
        <h2>Input JSON</h2>
        <textarea id="input"></textarea>
        <button onclick="loadJson()">Load JSON</button>
      </div>

      <div class="resizer"></div>

      <div class="panel center">
        <h2>Level</h2>
        <select id="levelSelect" onchange="changeLevel()"></select>

        <h2>Bonus Words</h2>
        <input
          id="bonusInput"
          placeholder="ENTER BONUS WORD"
          oninput="this.value = this.value.toUpperCase()"
        />
        <button onclick="addBonus()">Add Bonus</button>
        <div id="bonusList" class="list"></div>

        <h2>Recently Removed</h2>
        <div id="removedList" class="list"></div>

        <h2>Possible Words</h2>
        <input
          id="searchInput"
          placeholder="Search..."
          oninput="renderPossible()"
        />

        <input type="file" id="dictFile" accept=".json" />
        <label>
          <input type="checkbox" id="dictOnly" onchange="renderPossible()" />
          Show dictionary words only
        </label>

        <div id="possibleList" class="list"></div>
      </div>

      <div class="resizer"></div>

      <div class="panel right">
        <h2>Output JSON</h2>
        <textarea id="output"></textarea>
      </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
      let data = null;
      let levelIndex = 0;
      let recentlyRemoved = [];
      let dictionary = null;

      const reverse = (s) => s.split("").reverse().join("");

      function showToast(msg) {
        const t = document.getElementById("toast");
        t.textContent = msg;
        t.classList.add("show");
        setTimeout(() => t.classList.remove("show"), 2000);
      }

      /* ===== Dictionary Loader (LOCAL SAFE) ===== */
      document.getElementById("dictFile").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = () => {
          try {
            const raw = JSON.parse(reader.result);

            // ðŸ”¥ NORMALIZE HERE
            dictionary = new Set(Object.keys(raw).map((w) => w.toUpperCase()));

            showToast(`Dictionary loaded (${dictionary.size} words)`);
            renderPossible();
          } catch {
            showToast("Invalid dictionary file");
          }
        };
        reader.readAsText(file);
      });

      /* ===== JSON ===== */
      function loadJson() {
        try {
          data = JSON.parse(input.value);
        } catch {
          showToast("Invalid JSON");
          return;
        }

        levelSelect.innerHTML = "";
        data.levels.forEach((l, i) => {
          const o = document.createElement("option");
          o.value = i;
          o.textContent = l.levelname;
          levelSelect.appendChild(o);
        });

        levelIndex = 0;
        recentlyRemoved = [];
        render();
      }

      function changeLevel() {
        levelIndex = +levelSelect.value;
        recentlyRemoved = [];
        render();
      }

      /* ===== Bonus ===== */
      function addBonus() {
        if (!data) return;
        const word = bonusInput.value.trim();
        if (!word) return;

        const lvl = data.levels[levelIndex];
        if (lvl.bonusWords.includes(word)) return showToast("Already exists");

        lvl.bonusWords.push(word);
        bonusInput.value = "";
        render();
      }

      /* ===== Render ===== */
      function render() {
        renderBonus();
        renderRemoved();
        renderPossible();
        output.value = JSON.stringify(data, null, 2);
      }

      function getGrid(level) {
        return level.grid.map((r) => r.letters);
      }

      /* ===== Word Scan ===== */ function getConstructibleWords(level) {
        const grid = getGrid(level);
        const rows = grid.length;
        const cols = grid[0].length;
        const set = new Set();

        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
          [1, 1],
          [-1, -1],
          [1, -1],
          [-1, 1],
        ];

        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            for (const [dx, dy] of dirs) {
              let cx = x;
              let cy = y;
              let w = "";

              while (cx >= 0 && cy >= 0 && cx < cols && cy < rows) {
                // ðŸ”¥ NORMALIZE GRID LETTER
                w += grid[cy][cx].toUpperCase();

                if (w.length >= 3) set.add(w);
                cx += dx;
                cy += dy;
              }
            }
          }
        }
        return set;
      }

      function renderBonus() {
        bonusList.innerHTML = "";
        const lvl = data.levels[levelIndex];
        const validSet = getConstructibleWords(lvl);

        lvl.bonusWords.forEach((w, i) => {
          const d = document.createElement("div");
          d.className = "word bonus" + (validSet.has(w) ? "" : " invalid");
          d.textContent = w;
          d.onclick = () => {
            lvl.bonusWords.splice(i, 1);
            recentlyRemoved.unshift(w);
            render();
          };
          bonusList.appendChild(d);
        });
      }

      function renderRemoved() {
        removedList.innerHTML = "";
        recentlyRemoved.forEach((w, i) => {
          const d = document.createElement("div");
          d.className = "word removed";
          d.textContent = w;
          d.onclick = () => {
            data.levels[levelIndex].bonusWords.push(w);
            recentlyRemoved.splice(i, 1);
            render();
          };
          removedList.appendChild(d);
        });
      }

      function renderPossible() {
        possibleList.innerHTML = "";
        const lvl = data.levels[levelIndex];
        const search = searchInput.value.toUpperCase();
        const dictOnly = dictOnlyCheckbox.checked;
        const words = getConstructibleWords(lvl);

        const blocked = new Set();
        lvl.words.forEach((w) => {
          blocked.add(w.text);
          blocked.add(reverse(w.text));
        });

        [...words]
          .filter((w) => !lvl.bonusWords.includes(w))
          .filter((w) => !search || w.includes(search))
          .filter((w) => !dictOnly || (dictionary && dictionary.has(w)))
          .sort()
          .forEach((w) => {
            const d = document.createElement("div");
            d.className = "word possible";
            d.textContent = w;

            if (blocked.has(w) || blocked.has(reverse(w))) {
              d.classList.add("blocked");
            } else {
              d.onclick = () => {
                lvl.bonusWords.push(w);
                render();
              };
            }
            possibleList.appendChild(d);
          });
      }

      const dictOnlyCheckbox = document.getElementById("dictOnly");
    </script>
  </body>
</html>
